//
//  File.swift
//  
//
//  Created by Murph on 2022/5/23.
//

import Foundation
/**
          时间复杂度       空间复杂度      排序稳定性
选择排序:      O(N^2)           O(1)            NO
冒泡排序:      O(N^2)           O(1)            YES
插入排序:      O(N^2)           O(1)            YES
归并排序:      O(N*logN)        O(N)            YES // 归并相等值的时候要先归并左侧数
快排:         O(N*logN)        O(logN)          NO
堆排序：       O(N*logN)        O(1)             NO

基于比较的排序，时间复杂度目前不会小于 O(N*logN)
如果排序算法的时间复杂度为 O(N*logN)，空间复杂度不会小于 O(N)

常见的坑：
1. 归并排序的额外空间复杂度可以变成 O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序，内部缓存法”  // 变完之后不再稳定（可以直接用堆代替）
2. “原地归并排序”的帖子都是垃圾，会让归并排序的事件复杂度变为 O(N^2)  // 有现成可以替代的
3. 快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜 “01 stable sort”  // 但是空间复杂度会变为 O(N)，那可以用归并代替
4. 所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，空间复杂度O(1)，又稳定的排序

5. 可怼，奇数放数组左边，偶数放数组右边，并且要求原始相对次序不变，额外空间复杂度 O(1)，时间复杂度 O(N)
 经典快排的 partition 做不到稳定性，经典快排的 partition 又是 0 1 标准，同奇偶问题是一种调整策略，快排做不到，所以这里也做不到
 
 
 综合排序：
 充分利用 O(N*logN)和O(N^2)排序各自的优势
 大样本量：使用快排或者归并的调度 O(N*logN)
 小样本量: 使用插入 O(N^2) 跑的更快一些
 
 稳定性考虑
 基础类型的话可以使用快排，如果是非基础类型为了稳定那么使用归并
*/
class Sort {}
